POS to canonical POS:
Given a POS boolean function (expr & variables):
1. From expr extract the components: identify them by reading each character and if there is no "*" to split it add the vars into a list of list. e.g. qp + !r would extract [(p,q), !r]. Note that the extraction is done in order where the order is {p, q, r} set by the vars parameter.
2. Each component must have all variables (def. canonical expr). In order to achieve this it must be done recursively (or if there is any other method use it) until the target component has all the variables (by the order set in vars)  then insert them into a set. Remember that the order of a negation is the same as the if it doesn't have the negation (!). 
3. After getting all the set it is needed to order the set. The order is now set by the standard truth table evaluation. Namely if we had two variables {p, q}
the evaluation would be:
P Q
1 1
1 0
0 1
0 0
So if we had finally:
{{p, !q}, {p,q}}
i should be ordererd by
[{p,q}, {p, !q}] #i think this should be a list of lists

this is the part that i get more trouble with, p = 1 (OR TRUTH) and !p = 0 (or false). if we had more variables the first variables should be evaluated (for ordering reasons) as 2^(n-m) ones and then 2^(n-m) zeros until it reaches the n evaluations where n is the number of variables and m is the place of that varaible in the least (not the index, instead index + 1). so if we had 4 variables as vars = {p, q, r, s}: 
p: 2^(4-1) = 8 ones and 8 zeros (in that order) as filling 8 + 8 = 2^4 then p will filled as
p
1
1
1
1
0
0
0
0
for filling s we will have 2^(4-4) = 1; 1 one and 1 zero until it reaches 2^4.
so 
s
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
and so on until having all the variables evaluation, note that this must be done in order.
after having all the evuluations we should know that if we had
[p, q, r] and [!p !q !r] then (pqr) <  (!p !q !r) by the truth table evulation that we just made. somehow that must be achieved.
4. Display the canonical SOP. For each list of lists display it as (var1 + var2 + var3) * (var1 + var2 + var3) * ... var1 and so on are relatively to the component namely a var1 could be !p.
